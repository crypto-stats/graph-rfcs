<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0004: Fulltext Search - Graph Protocol RFCs and Engineering Plans</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../assets/mermaid.css">
        
        <link rel="stylesheet" href="../assets/custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../rfcs/index.html"><strong aria-hidden="true">2.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/approved.html"><strong aria-hidden="true">2.1.</strong> Approved RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/0001-subgraph-composition.html"><strong aria-hidden="true">2.1.1.</strong> RFC-0001: Subgraph Composition</a></li><li class="chapter-item expanded "><a href="../rfcs/0002-ethereum-tracing-cache.html"><strong aria-hidden="true">2.1.2.</strong> RFC-0002: Ethereum Tracing Cache</a></li><li class="chapter-item expanded "><a href="../rfcs/0003-mutations.html"><strong aria-hidden="true">2.1.3.</strong> RFC-0003: Mutations</a></li><li class="chapter-item expanded "><a href="../rfcs/0004-fulltext-search.html" class="active"><strong aria-hidden="true">2.1.4.</strong> RFC-0004: Fulltext Search</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/obsolete.html"><strong aria-hidden="true">2.2.</strong> Obsolete RFCs</a></li><li class="chapter-item expanded "><a href="../rfcs/rejected.html"><strong aria-hidden="true">2.3.</strong> Rejected RFCs</a></li></ol></li><li class="chapter-item expanded "><a href="../engineering-plans/index.html"><strong aria-hidden="true">3.</strong> Engineering Plans</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../engineering-plans/approved.html"><strong aria-hidden="true">3.1.</strong> Approved Plans</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../engineering-plans/0001-graphql-query-prefetching.html"><strong aria-hidden="true">3.1.1.</strong> PLAN-0001: GraphQL Query Prefetching</a></li><li class="chapter-item expanded "><a href="../engineering-plans/0002-ethereum-tracing-cache.html"><strong aria-hidden="true">3.1.2.</strong> PLAN-0002: Ethereum Tracing Cache</a></li><li class="chapter-item expanded "><a href="../engineering-plans/0003-remove-jsonb-storage.html"><strong aria-hidden="true">3.1.3.</strong> PLAN-0003: Remove JSONB Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../engineering-plans/obsolete.html"><strong aria-hidden="true">3.2.</strong> Obsolete Plans</a></li><li class="chapter-item expanded "><a href="../engineering-plans/rejected.html"><strong aria-hidden="true">3.3.</strong> Rejected Plans</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Graph Protocol RFCs and Engineering Plans</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rfc-0004-fulltext-search" id="rfc-0004-fulltext-search">RFC-0004: Fulltext Search</a></h1>
<dl>
  <dt>Author</dt>
  <dd>Ford Nickels</dd>
<dt>RFC pull request</dt>
  <dd><a href="https://github.com/graphprotocol/rfcs/pull/11">URL</a></dd>
<dt>Obsoletes (if applicable)</dt>
  <dd>-</dd>
<dt>Date of submission</dt>
  <dd>2020-01-05</dd>
<dt>Date of approval</dt>
  <dd>2020-02-10</dd>
<dt>Approved by</dt>
  <dd>Jannis Pohlmann</dd>
</dl>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#goals--motivation">Goals &amp; Motivation</a></li>
<li><a href="#urgency">Urgency</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#detailed-design">Detailed Design</a></li>
<li><a href="#subgraph-schema">Subgraph Schema</a></li>
<li><a href="#graphql-query-interface">GraphQL Query interface</a></li>
<li><a href="#tools-and-design">Tools and Design</a></li>
<li><a href="#compatibility">Compatibility</a></li>
<li><a href="#drawbacks-and-risks">Drawbacks and Risks</a></li>
<li><a href="#alternatives">Alternatives</a></li>
<li><a href="#open-questions">Open Questions</a></li>
</ul>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>The fulltext search filter type is a feature of the GraphQL API that
allows subgraph developers to specify language-specific, lexical,
composite filters that end users can use in their queries. The fulltext
search feature examines all words in a document, breaking it into
individual words and phrases (lexical analysis), and collapsing
variations of words into a single index term (stemming.)</p>
<h2><a class="header" href="#goals--motivation" id="goals--motivation">Goals &amp; Motivation</a></h2>
<p>The current set of string filters available in the GraphQL API is lacking 
fulltext search capabilities that enable efficient searches across entities
and attributes. Wildcard string matching does provide string filtering, but 
users have come to expect the easy to use filtering that comes with fulltext 
search systems.</p>
<p>To facilitate building effective user interfaces human-user friendly query 
filtering is essential. Lexical, composite fulltext search filters can provide 
the tools necessary for front-end developers to implement powerful search 
bars that filter data across multiple fields of an Entity.</p>
<p>The proposed feature aims to provide tools for subgraph developers to define 
composite search APIs that can search across multiple fields and entities.</p>
<h2><a class="header" href="#urgency" id="urgency">Urgency</a></h2>
<p>A delay in adding the fulltext search feature will not create issues
with current deployments. However, the feature will represent a
realization of part of the long term vision for the query network. In
addition, several high profile users have communicated that it may be a
conversion blocker. Implementation should be prioritized. </p>
<h2><a class="header" href="#terminology" id="terminology">Terminology</a></h2>
<ul>
<li>
<p><em>lexeme</em>: a basic lexical unit of a language, consisting of one word or 
several words, considered as an abstract unit, and applied to a family 
of words related by form or meaning.</p>
</li>
<li>
<p><em>morphology (linguistics)</em>: the study of words, how they are formed, 
and their relationship to other words in the same language. </p>
</li>
<li>
<p><em>fulltext search index</em>: the result of lexical and morphological 
analysis (stemming) of a set of text documents.  It provides frequency 
and location for the language-specific stems found in the text documents 
being indexed. </p>
</li>
<li>
<p><em>ranking algorithm</em>: &quot;Ranking attempts to measure how relevant documents 
are to a particular query, so that when there are many matches the most 
relevant ones can be shown first.&quot; <a href="https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-RANKING-SEARCH-RESULTS">- Postgres Documentation</a></p>
<p><strong>Algorithms</strong>:</p>
<ul>
<li><em>standard ranking</em>: ranking based on the number of matching lexemes.</li>
<li><em>cover density ranking</em>: Cover density is similar to the standard 
fulltext search ranking except that the proximity of matching lexemes 
to each other is taken into consideration. This function requires 
lexeme positional information to perform its calculation, so it ignores 
any &quot;stripped&quot; lexemes in the index.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#detailed-design" id="detailed-design">Detailed Design</a></h2>
<h3><a class="header" href="#subgraph-schema" id="subgraph-schema">Subgraph Schema</a></h3>
<p>Part of the power of the fulltext search API is the flexibility, so 
it is important to expose a simple interface to facilitate useful applications 
of the index and aim to reduce the need to create new subgraphs for the 
express purpose of updating fulltext search fields. </p>
<p>For each fulltext search API a subgraph developer must be able to specify:</p>
<ol>
<li>a language (specified using an <code>ISO 639-1</code> code), </li>
<li>a set of text document fields to include,</li>
<li>relative weighting for each field,</li>
<li>a choice of ranking algorithm for sorting query result items.</li>
</ol>
<p>The proposed process of adding one or more fulltext search API involves
adding one or more fulltext directive to the <code>_Schema_</code> type in the
subgraph's GraphQL schema. Each fulltext definition will have four
required top level parameters: <code>name</code>, <code>language</code>, <code>algorithm</code>, and
<code>include</code>. The fulltext search definitions will be used to generate
query fields on the GraphQL schema that will be exposed to the end user.</p>
<p>Enabling fulltext search across entities will be a powerful abstraction 
that allows users to search across all relevant entities in one query. Such 
a search will by definition have polymorphic results. To address this, a 
union type will be generated in the schema for the fulltext search results. </p>
<p>Validation of the fulltext definition will ensure that all fields referenced 
in the directive are valid String type fields. With subgraph composition 
it will be possible to easily create new subgraphs that add specific fulltext 
search capabilities to an existing subgraph. </p>
<p>Example fulltext search definition:</p>
<pre><code class="language-graphql">type _Schema_ 
  @fulltext(
    name: &quot;media&quot;
    ...
  )
  @fulltext(
    name: &quot;search&quot;,
    language: EN, # variant of `_FullTextLanguage` enum
    algorithm: RANKED, # variant of `_FullTextAlgorithm` enum
    include: [
      {
        entity: &quot;Band&quot;,
        fields: [
          { name: &quot;name&quot;, weight: 5 },
        ]
      },
      {
        entity: &quot;Album&quot;,
        fields: [
          { name: &quot;title&quot;, weight: 5 },
        ]
      },
      {
        entity: &quot;Musician&quot;,
        fields: [
          { name: &quot;name&quot;, weight: 10 },
          { name: &quot;bio&quot;, weight: 5 },
        ]
      }
    ]
  )
</code></pre>
<p>The schema generated from the above definition: </p>
<pre><code class="language-graphql">union _FulltextMediaEntity = ...
union _FulltextSearchEntity = Band | Album | Musician
type Query {
  media...
  search(text: String!, first: Int, skip: Int, block: Block_height): [FulltextSearchResultItem!]!
}
</code></pre>
<h3><a class="header" href="#graphql-query-interface" id="graphql-query-interface">GraphQL Query interface</a></h3>
<p>End users of the subgraph will have access to the fulltext search
queries alongside the other queries available for each entity in the
subgraph. In the case of a fulltext search defined across multiple
entities,
<a href="https://graphql.org/learn/queries/#inline-fragments">inline fragments</a>
may be used in the query to deal with the polymorphic result items. In
the front-end the <code>__typename</code> field can be used to distinguish the
concrete entity types of the returned results.</p>
<p>In the <code>text</code> parameter supplied to the query there will be several operators
available to the end user.  Included are the and, or, and proximity operators
(<code>&amp;</code>, <code>|</code>, <code>&lt;-&gt;</code>.) The special, proximity operator allows clients to specify 
the maximum distance between search terms: <code>foo&lt;3&gt;bar</code> is equivalent to 
requesting that <code>foo</code> and <code>bar</code> are at most three words apart. </p>
<p>Example query using inline fragments and the proximity operator: </p>
<pre><code class="language-graphql">query {
  search(text: &quot;Bob&lt;3&gt;run&quot;) {
    __typename
    ... on Band { name label { id } }
    ... on Album { title numberOfTracks }
    ... on Musician { name bio }
  }
}
</code></pre>
<h3><a class="header" href="#tools-and-design" id="tools-and-design">Tools and Design</a></h3>
<p>Fulltext search query system implementations often involve specific systems 
for storing and querying the text documents; however, in an effort to reduce 
system complexity and feature implementation time I propose starting with 
extending the current store interface and storage implemenation with fulltext 
search features rather than use a fulltext specific interface and storage
system.</p>
<p>A FullText search field will get its own column in a table dedicated to fulltext
data. The data stored will be the result of the lexical, morphological analysis 
of text documents performed on the fields included in the index. The fulltext 
search field will be created using the Postgres ts_vector function and will 
be indexed using a GIN index. The subgraph developer will define a ranking 
algorithm to be used to sort query results,so the end-user facing API remains 
easy to use without any requirement to understand the ranking algorithms.</p>
<h2><a class="header" href="#compatibility" id="compatibility">Compatibility</a></h2>
<p>This proposal does not change any existing interfaces, so no migrations 
will be necessary for existing subgraph deployments. </p>
<h2><a class="header" href="#drawbacks-and-risks" id="drawbacks-and-risks">Drawbacks and Risks</a></h2>
<p>The proposed solution uses native Postgres fulltext features and there is 
a nonzero probability this choice results in slower than optimal write and 
read times; however the tradeoff in implementation time/complexity and the 
existence of production use case testimonials tempers my apprehension here. </p>
<p>In future phases of the network the storage layer may get a redesign with 
indexes being overhauled to facilitate query result verification. Postgres
based fulltext search implementation would not be translatable to another 
storage system, so at the least a reevaluation of the tools used for analysis, 
indexing, and querying would be required.</p>
<h2><a class="header" href="#alternatives" id="alternatives">Alternatives</a></h2>
<p>An alternative design for the feature would allow more flexibility for
Graph Node operators in their index implementation and create a
marketplace for indexes. In the alternate, the definition of fulltext
search indexes could be moved out of the subgraph schema. The subgraph
would be deployed without them and they could be added later using a new
Graph Explorer interface (in Hosted-Service context) or a JSON-RPC
request directly to a Graph Node. Moving the creation of fulltext search
indexes/queries out of the schema would mean that that the definition of
uniqueness for a subgraph does not include the custom indexes, so a new
subgraph deployment and subgraph re-syncing work does not have to be
added in order to create or update an index. However, it also introduces
significant added complexity. A separate query marketplace and discovery
registry would be required for finding nodes with the needed
subgraph-index combination.</p>
<h2><a class="header" href="#open-questions" id="open-questions">Open Questions</a></h2>
<p>Full-text search queries introduce new issues with maintaining query 
result determinism which will become a more potent issue with the 
decentralized network. A fulltext search query and a dataset are not enough 
to determine the output of the query, the index is vital to establish a 
deterministic causal relationship to the output data.  Query verification 
will need to take into account the query, the index, the underlying dataset, 
and the query result.  Can we find a healthy compromise between being 
prescriptive about the indexes and algorithms in order to allow formal 
verification and allowing indexer node operators to experiment with 
algorithms and indexes in order to continue to improve query speed and results? </p>
<p>Since a fulltext search field is purely derivative of other Entity data
the addition or update of an @fulltext directive does not require a full
blockchain resync, rather the index itself just needs to be rebuilt.
There is room for optimization in the future by allowing fulltext search
definition updates without requiring a full subgraph resync.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../rfcs/0003-mutations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../rfcs/obsolete.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../rfcs/0003-mutations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../rfcs/obsolete.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../assets/mermaid.min.js"></script>
        
        <script type="text/javascript" src="../assets/mermaid-init.js"></script>
        

        

    </body>
</html>
